## functions for processing sequence files generated by STRaitrazor 2
library(dplyr)
library(tidyr)
library(magrittr)
library(ggplot2)
source("get_counts.R")
source("calc_str_metrics.R")

### -----Process Sequences Files -----------------------------------------------
###
### functions for reading sequence files generated by straitrazor  
### and compiling into a single data frame
###
process_sequence_file <- function(seq_file, read){
    #This will output a warning if the file is empty and therefore not upload it.
    df <- try(read.table(seq_file,sep ="\t", stringsAsFactors=F))
    if(class(df)=='try-error') {
        warning(paste0(seq_file, "is empty"))
        return()
    }
    #This will separate the first comlum into two (one for Locus and one for Allele number), rename
    #the rest of the columns, and add a new column that contains the read (R1 or R2)
    read.table(file=seq_file, header=FALSE, sep="\t") %>% 
        separate(V1, into = c("Locus", "Allele"), sep = ":") %>% 
        rename(Allele_Calls = V4, Size = V2, Sequence = V3) %>% 
        mutate(Allele_Calls = as.integer(Allele_Calls), Read = read)
}

    #This function will bind all the rows together to make one giant data frame
    #containing all the information for the .sequence files. 
process_sequences_directory <- function(root_dir, paired = TRUE){
    df <- data_frame()
#     for(read in c("R1", "R2")){
#         directory <- paste0(root_dir,"/", read,"/")
#         if(!dir.exists(directory)){
#             dir.create(directory)
#         }
#         for(seq_file in list.files(directory, "sequences",full.names = TRUE)){
#             seq_df <- process_sequence_file(seq_file,read)
#             df <- bind_rows(df, seq_df)   
#         }
#     }
    if(paired){
        for(read in c("R1", "R2")){
             directory <- paste0(root_dir,"/", read,"/")
             for(seq_file in list.files(directory, "sequences",full.names = TRUE)){
                 seq_df <- process_sequence_file(seq_file,read)
                 df <- bind_rows(df, seq_df)
             }
         }
    #This is what to do if there is only a R1 in the initial data
     }else{
         directory <- paste0(root_dir,"/R1/")
         for(seq_file in list.files(directory, "sequences",full.names = TRUE)){
             seq_df <- process_sequence_file(seq_file,read)
             df <- bind_rows(df, seq_df)
         }
     }
    df
}

### -----Process Allele Calls Files --------------------------------------------
###
### functions for reading allele calls files generated by straitrazor 
### and compiling into a single data frame
###

process_allelecalls_file <- function(txt_file, read){
    # no need to name differently from process_seqeunces as they are in 
    # different environments, they can't see eachother
    df <- try(read.table(txt_file,sep =",", stringsAsFactors=F))
    if(class(df)=='try-error') {
        warning(paste0(txt_file, "is empty"))
        return()
    }
    read.table(txt_file, sep=",", stringsAsFactors=F) %>% 
        head(-1) %>% 
        separate(V1, 
                 into = c("Locus", "Read", "Locus", "Allele", "Allele_Calls"), 
                 sep = ":")  
    
}

process_allelecalls_directory <- function(root_dir, paired = TRUE){
    df <- data_frame()
    if(paired){
        for(read in c("R1", "R2")){
            directory <- paste0(root_dir,"/", read,"/")
            for(txt_file in list.files(directory, "txt",full.names = TRUE)){
                df %<>% bind_rows(process_allelecalls_file(txt_file,read))
            }
            
        }
    }else{
        #%%TODO%%
        warning("No code for unpaired read data")
    }
    df
}

process_single_sample <- function (seq_dir, batch = FALSE) {
    seq_df <- process_sequences_directory(seq_dir)
    allele_counts_df <- str_allele_counts(seq_df)
    single_summary_met <- calc_allele_metrics(allele_counts_df) %>% mutate(Sample = seq_dir)
    
    if(batch){
        return(single_summary_met)
    }
    # change output file name - sample specific
    write.table(single_summary_met, "single_summary.csv", sep = ",", 
                row.names = FALSE) 
}

batch_process_samples  <- function (sample_dirs) {
     if (file.exists("summary.csv")){
         unlink("summary.csv")
     }
    for (dirs in sample_dirs) {
        summary_met <- process_single_sample(dirs, batch = TRUE) 
        write.table(summary_met, "summary.csv", append = TRUE, sep = ",", 
               row.names = FALSE, col.names=!file.exists("summary.csv")) 
    }
}